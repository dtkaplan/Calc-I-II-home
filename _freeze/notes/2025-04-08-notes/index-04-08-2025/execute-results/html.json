{
  "hash": "bb7143104e94a22f79c000bf0794b364",
  "result": {
    "engine": "knitr",
    "markdown": "---\nauthor: DTK\ndate: 2025-04-08\nnumber-offset: 33\nformat: live-html\n---\n\n\n\n\n\n\n::: {.callout-warning collapse=true}\n## Background software\n```{webr-r}\n#| autorun: true\n#| context: setup\n# Drawing vectors and matrices\n\ndraw_matrix <- function(M) {\n  image(1:ncol(M), 1:nrow(M), t(M[nrow(M):1, ]),\n        col = colorspace::diverging_hcl(\n          15, h = c(180, 50), c = 80,\n          l = c(20, 95), power = c(0.7, 1.3)),\n        axes = FALSE)\n}\n\nsomevecs <- tibble::tribble(\n  ~ rootx, ~ rooty, ~ headx, ~ heady, ~ color, ~ name,\n  0, 0, -2, 4, \"blue\", \"u\",\n  1, -2, 5, -3, \"green\", \"v\",\n  -1, -1, -4, -1, \"orange\", \"w\",\n  1, 0, 4, 3, \"brown\", \"x\",\n  0, -2, 3, -3, \"salmon\", \"y\",\n  0, 0, 4, 3, \"magenta\", \"b1\",\n  0, 0, -3, 2, \"magenta\", \"b2\",\n) |>\n  mutate(labelx = (rootx + headx)/2,\n         labely = (2*rooty + heady)/3)\nsolve_for <- function(vecnames) {\n  somevecs |>\n    filter(name %in% vecnames) |>\n    gf_segment(rooty + heady ~ rootx + headx,\n               arrow = grid::arrow(length=unit(0.15, \"inches\"), type=\"closed\"),\n               color = ~ color, linewidth=2) |>\n    gf_label(labely ~ labelx, label= ~ name, color = ~ color, size=3) |>\n    gf_refine(scale_color_identity(),\n              scale_y_continuous(limits=c(-5,5),\n                                 breaks=(-5):5),\n              scale_x_continuous(limits=c(-5,5),\n                                 breaks=(-5):5),\n              coord_fixed()) |>\n    gf_labs(x=\"\", y = \"\")\n}\n\n\n# Simple vector/matrix operations\n\nvec <- function(...) {\n  vals <- list(...) |> unlist()\n  matrix(vals, ncol=1)\n}\n\nrvec <- function(first, ..., rfun=rnorm) {\n  dots <- c(first, list(...)) |> unlist()\n  if (length(dots) == 1) {\n    dots <- rfun(dots[[1]])\n  }\n\n  vec(dots)\n}\n\nveclen <- function(v) sqrt(v %dot% v)\nunitvec <- function(vec) vec/length(vec)\ncang <- function(v, w) {(v %dot% w) / (veclen(v) * veclen(w))}\nmakeQ <- function(...) {\n  dots <- list(...) |> bind_cols()\n  qr.Q(qr(dots))\n}\n\ncheck_for_svd <- function(S) {\n  if (inherits(S, \"matrix\")) S <- svd(S)\n  if (!is.list(S) || !all(c(\"d\",\"v\", \"u\") %in% names(S)))\n    stop(\"Argument must be matrix or the SVD of a matrix.\")\n  S\n}\n\nrank_mat <- function(S, thresh = 0.01) {\n  S <- check_for_svd(S)\n  sum(S$d > S$d[1] * thresh)\n}\n\nrand_mat <- function(nrow=3, ncol=6, rank = pmin(nrow, ncol)) {\n  M <- matrix(runif(nrow*ncol), nrow = nrow, ncol = ncol)\n  if (rank >= nrow || rank >= ncol) {\n   M\n  } else {\n    approx_mat(S, n=sample(pmin(rank, nrow, ncol)))\n  }\n}\n\n# Grab rank 1 matrix from SVD\napprox_mat <- function(S, n=1, order = 0) { # input a matrix or the SVD of a matrix\n  S <- check_for_svd(S)\n  if (order > 0) {\n    inds1 <- order(c(S$u[,order]))\n    inds2 <- order(c(S$v[,order]))\n  } else {\n    inds1 <- 1:nrow(S$u)\n    inds2 <- 1:nrow(S$v)\n  }\n  partial <- 0 # initial value\n  for (k in n) {\n    partial <- partial +  S$d[k] * S$u[inds1,k, drop = FALSE] %*% t(S$v[inds2,k, drop = FALSE])\n  }\n\n  partial\n}\n\npretty_mat <- function(M) {\n  inds1 <- order(rowSums(M))\n  inds2 <- order(colSums(M))\n  M[inds1, inds2]\n}\n\n#' Generate a matrix whose elements are selected randomly from a set\n#' of specified values.\n#' @param nrow number of rows for the matrix produced\n#' @param ncol number of columns\n#' @param values the set from which to draw (randomly) the\n#' values in the matrix. Default: integers -9 to 9\nvalues_mat <- function(nrow=4, ncol=3, values = -9:9) {\n  matrix(sample(values, size = nrow * ncol, replace = TRUE),\n         nrow = nrow, ncol=ncol)\n}\n\n```\n:::\n\n# 2025-04-08 class notes\n\n::: {.callout-tip collapse=true}\n## Console A\n```{webr-r}\n#| persist: true\n\n```\n:::\n\n::: {.callout-tip collapse=true}\n## Console B\n```{webr-r}\n#| persist: true\n\n```\n:::\n\n::: {.callout-tip collapse=true}\n## Console C\n```{webr-r}\n#| persist: true\n\n```\n:::\n\n\n## From last week ...\n\nWe talked about the dot product, linear combinations, the idea of a subspace as defined by a set of vectors. \n\nWe started to think about linear modeling (as in `model_train()`, which uses `lm()`) in terms of vectors.\n\nReminder of \"case space\" versus \"variable space.\"\n\n\nToday's goal is to give you a complete understanding of linear modeling in terms of vectors. \n\n## Matrices\n\nA matrix is a set of vectors. All of them must share an embedding space, that is, they all must have the same number of components.\n\n* Making vectors, say with `rvec()`\n* Making matrices with `cbind()`\n* Sometimes it will be nice to display a large matrix visually, one pixel per number.\n\n\nExample: Matrix of random numbers\n\n```{webr-r}\n#| caption: A random matrix\nMrand <- matrix(rnorm(40*30), nrow=40, ncol=30)\ndraw_matrix(Mrand)\n```\n\n## Grabbing components of matrices\n\nOccasionally, we will need to look at just one (or a few) columns (or rows) in a matrix. We can use the **indexing syntax** for this, which involves square braces: `[ , ]`\n\nExample: Matrix of small integers\n\n```{webr-r}\nM <- values_mat(4, 3)\nM\nM[1, ]  # first row\nM[ , 1] # first column\n```\n\nNow for an R oddity. The people who initially wrote S (the precursor to R) created an object called a \"vector\" that, unlike the linear algebra conception, doesn't distinguish between rows and columns. The *indexing operator* will collapse the result to an R vector, if it can.\n\nTo get the matrix part correctly formatted, you need to cancel this behavior:\n\n```{webr-r}\nM[1,  , drop = FALSE]\nM[ , 1, drop = FALSE]\n```\n\n## Matrix/vector multiplication\n\nCanonical form: m-by-n matrix times an n-dimensional vector gives an m-dimensional vector.\n\nThe *times* here is not scalar multiplication. It is \"**matrix multiplication**.\" The operator is\n\n[`%*%`]{style=\"font-size: xxx-large;\"}\n\nYou will mistakenly use simple `*` often. Be gentle with yourself!\n\nThe result is a *linear combination of the vectors in the matrix*, with the \"coefficients\"/\"scalars\" coming from the vector. \n\n```{webr-r}\nM %*% vec(1,0,-1)\n```\n\nNot necessarily commutative. \n\nWhy I was dodgy in writing the dot product using two column vectors. Better if the dot product is seen as a kind of matrix/vector multiplication, where the matrix consists simply as a row of scalars.\n\nUse `values_mat()` to create the vectors and the matrix.\n\n# Finding the coefficients using `lm()`\n\n```{webr-r}\nv <- values_mat(4, 1)\nM <- values_mat(4, 4)\nlist(M=M, v=v) |>\n  model_train(v ~ M - 1) |>\n  conf_interval()\n```\n\nHow does `model_train()` manage this? It calls a more basic function `lm()` (short for \"linear model\") which in turn calls `qr.solve()` which in turn calls a linear algebra package called \"LINPACK\" or a newer system \"LAPACK\" that's used by technical workers world-wide.\n\n```{webr-r}\nqr.solve(M, v)\n```\n\n## Q and R matrices\n\n`qr.solve()` takes the matrix and re-writes it as a linear combination of two special matrices, one called Q and the other R. \n\n```{webr-r}\nmyQ <- qr.Q(qr(M))\nmyR <- qr.R(qr(M))\nmyQ\nmyR\nmyQ %*% myR\n```\n\nEach of the vectors in Q is orthogonal to every other vector in Q. \n\n```{webr-r}\nmyQ[,1] %dot% myQ[,1]\nmyQ[,1] %dot% myQ[,2]\n```\n\nThe `%dot%` operator is really a special form of matrix multiplication, arranged to disregard whether vectors are in row or column format. With matrix multiplication, we have to be more careful.\n\n```{webr-r}\nmyQ[, 1:2]\nmyQ[, 1, drop=FALSE]\nt(myQ[, 1:2])\nt(myQ[, 1:2]) %*% myQ[, 1, drop = FALSE]\n\n```\n\n\nThe R matrix is also special.  To illustrate, let's solve a made-up set of equations:\n\n```{webr-r}\nR1 <- cbind(vec(4, 0), vec(-2, 6))\nTarget1 <- vec(8, 12)\nR1 \nTarget1\nqr.solve(R1, Target1)\n```\n\n```{web-r}\nmyR\n```\n\n```{webr-r}\nM[, 1, drop=FALSE]\nmyQ[ , 1, drop=FALSE] * 11.09045\n```\n\nThen work out the second column of M as a linear combination of the first *two* vectors in myQ.\n\n\n## Projection onto a subspace\n\nLet's look at the space spanned by the second and third vector in M\n\n\n```{webr-r}\nmySpace <- M[, 2:3]\nmySpace\ntarget <- vec(1,2,3,4)\n```\n\nProject the target vector onto mySpace\n```{webr-r}\ntarget %onto% mySpace\nqr.solve(mySpace, target)\nmySpace %*% qr.solve(mySpace, target)\n```\n\n\n```{webr-r}\nt(qr.Q(qr(mySpace))) %*% target\n```\n\n```{webr-r}\nqr.R(qr(mySpace))\n```\n\n## Getting to Q\n\nGraham-Schmidt orthogonalization \n\nDo an example by hand.\n\n```{webr-r}\n\n```\n\n\n## Functions as vectors\n\nGaussians over a two second-window\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstep = 2^(1/12)\n\nSounds <- tibble::tibble(\n  time = (0:44100)/22050,\n  g1 = pmin(1.0, dnorm(time, mean = 1, sd=0.5)),\n  g2 = pmin(1.0, dnorm(time, mean = 0.25, sd=0.2)),\n  g3 = pmin(1.0, dnorm(time, mean = .75, sd=0.2)),\n  g4 = pmin(1.0, dnorm(time, mean = 1.25, sd=0.1)),\n  one =    sin(step^0  * 2 * pi * 440 * time),\n  two =    sin(step^1  * 2 * pi * 440 * time),\n  three =  sin(step^2  * 2 * pi * 440 * time),\n  four =   sin(step^3  * 2 * pi * 440 * time),\n  five =   sin(step^4  * 2 * pi * 440 * time),\n  six =    sin(step^5  * 2 * pi * 440 * time),\n  seven =  sin(step^6  * 2 * pi * 440 * time),\n  eight =  sin(step^7  * 2 * pi * 440 * time),\n  nine =   sin(step^8  * 2 * pi * 440 * time),\n  ten =    sin(step^9  * 2 * pi * 440 * time),\n  eleven = sin(step^10 * 2 * pi * 440 * time),\n  twelve = sin(step^11 * 2 * pi * 440 * time)\n)  |>\n  mutate(sum = g2*three + g2*five + g2*seven + 2*three^2)\n\naudio::play(Sounds$sum / 10, rate = 22050)\n```\n:::\n\n\n\n\n\n\n\n## SVD and the dimension of subspaces\n\nCreate some vectors, then some linear combinations of them than look at the singular values.\n\n```{webr-r}\nu <- rbind(1,2,3, 6, -2)\nv <- rbind(2,5,3, -4, 1)\nw <- 3*u - 2*v\nx <- w - u\ny <- u + v - w\nM <- cbind(u, v, w, x, y)\nM |> svd() |> purrr::pluck(\"d\")\n```\n\n```{webr-r}\ndraw_matrix(M)\nM\n```\n\n```{webr-r}\nM <- Sounds |> \n  select(one, two, three, four, five, \n         six, seven, eight, nine, ten, eleven, twelve) |>\n  as.matrix(ncol = 12) \nM |> svd() |> purrr::pluck(\"d\")\n```\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}