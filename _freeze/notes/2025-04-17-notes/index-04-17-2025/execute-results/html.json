{
  "hash": "d71f1693a385a10f5c81c08600c22f9e",
  "result": {
    "engine": "knitr",
    "markdown": "---\nauthor: DTK\ndate: 2025-04-17\nnumber-offset: 36\nformat: live-html\nwebr:\n  channel-type: 'automatic'\n  repos: [\"https://dtkaplan.r-universe.dev\"]\n  packages: ['ggplot2', 'mosaicCalc', \"LSTbook\" ]\nfilters:\n  - webr\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.callout-tip collapse=true}\n## Background software\n```{webr-r}\n#| autorun: true\n#| context: output\n# Drawing vectors and matrices\n\ndraw_matrix <- function(M) {\n  image(1:ncol(M), 1:nrow(M), t(M[nrow(M):1, ]),\n        col = colorspace::diverging_hcl(\n          15, h = c(180, 50), c = 80,\n          l = c(20, 95), power = c(0.7, 1.3)),\n        axes = FALSE,\n        useRaster = TRUE)\n}\n\nsomevecs <- tibble::tribble(\n  ~ rootx, ~ rooty, ~ headx, ~ heady, ~ color, ~ name,\n  0, 0, -2, 4, \"blue\", \"u\",\n  1, -2, 5, -3, \"green\", \"v\",\n  -1, -1, -4, -1, \"orange\", \"w\",\n  1, 0, 4, 3, \"brown\", \"x\",\n  0, -2, 3, -3, \"salmon\", \"y\",\n  0, 0, 4, 3, \"magenta\", \"b1\",\n  0, 0, -3, 2, \"magenta\", \"b2\",\n) |>\n  dplyr::mutate(labelx = (rootx + headx)/2,\n         labely = (2*rooty + heady)/3)\nsolve_for <- function(vecnames) {\n  somevecs |>\n    dplyr::filter(name %in% vecnames) |>\n    gf_segment(rooty + heady ~ rootx + headx,\n               arrow = grid::arrow(length=unit(0.15, \"inches\"), type=\"closed\"),\n               color = ~ color, linewidth=2) |>\n    gf_label(labely ~ labelx, label= ~ name, color = ~ color, size=3) |>\n    gf_refine(scale_color_identity(),\n              scale_y_continuous(limits=c(-5,5),\n                                 breaks=(-5):5),\n              scale_x_continuous(limits=c(-5,5),\n                                 breaks=(-5):5),\n              coord_fixed()) |>\n    gf_labs(x=\"\", y = \"\")\n}\n\n\n# Simple vector/matrix operations\n\nvec <- function(...) {\n  vals <- list(...) |> unlist()\n  matrix(vals, ncol=1)\n}\n\nrvec <- function(first, ..., rfun=rnorm) {\n  dots <- c(first, list(...)) |> unlist()\n  if (length(dots) == 1) {\n    dots <- rfun(dots[[1]])\n  }\n\n  vec(dots)\n}\n\nveclen <- function(v) sqrt(v %dot% v)\nunitvec <- function(vec) vec/length(vec)\ncang <- function(v, w) {(v %dot% w) / (veclen(v) * veclen(w))}\nmakeQ <- function(...) {\n  dots <- list(...) |> bind_cols()\n  qr.Q(qr(dots))\n}\n\ncheck_for_svd <- function(S) {\n  if (inherits(S, \"matrix\")) S <- svd(S)\n  if (!is.list(S) || !all(c(\"d\",\"v\", \"u\") %in% names(S)))\n    stop(\"Argument must be matrix or the SVD of a matrix.\")\n  S\n}\n\nrank_mat <- function(S, thresh = 0.01) {\n  S <- check_for_svd(S)\n  sum(S$d > S$d[1] * thresh)\n}\n\nrand_mat <- function(nrow=3, ncol=6, rank = pmin(nrow, ncol)) {\n  M <- matrix(runif(nrow*ncol), nrow = nrow, ncol = ncol)\n  if (rank >= nrow || rank >= ncol) {\n   M\n  } else {\n    approx_mat(S, n=sample(pmin(rank, nrow, ncol)))\n  }\n}\n\n# Grab rank 1 matrix from SVD\napprox_mat <- function(S, n=1, order = 0) { # input a matrix or the SVD of a matrix\n  S <- check_for_svd(S)\n  if (order > 0) {\n    inds1 <- order(c(S$u[,order]))\n    inds2 <- order(c(S$v[,order]))\n  } else {\n    inds1 <- 1:nrow(S$u)\n    inds2 <- 1:nrow(S$v)\n  }\n  partial <- 0 # initial value\n  for (k in n) {\n    partial <- partial +  S$d[k] * S$u[inds1,k, drop = FALSE] %*% t(S$v[inds2,k, drop = FALSE])\n  }\n\n  partial\n}\n\npretty_mat <- function(M) {\n  inds1 <- order(rowSums(M))\n  inds2 <- order(colSums(M))\n  M[inds1, inds2]\n}\n\n#' Generate a matrix whose elements are selected randomly from a set\n#' of specified values.\n#' @param nrow number of rows for the matrix produced\n#' @param ncol number of columns\n#' @param values the set from which to draw (randomly) the\n#' values in the matrix. Default: integers -9 to 9\nvalues_mat <- function(nrow=4, ncol=3, values = -9:9) {\n  matrix(sample(values, size = nrow * ncol, replace = TRUE),\n         nrow = nrow, ncol=ncol)\n}\n\n# Typeset matrices in LaTeX (for assignments and such)\nLmat <- function(nr, nc) {\n  values_mat(nr, nc) |> latex_helper()\n}\nlatex_helper <- function(matr) {\n  printmrow <- function(x) {\n\n    cat(cat(x,sep=\" & \"),\"\\\\\\\\ \\n\")\n  }\n\n  cat(\"\\\\left(\\\\begin{array}{r}\",\"\\n\")\n  body <- apply(matr,1,printmrow)\n  cat(\"\\\\end{array}\\\\right)\")\n}\n\n# Fourier transform stuff\n# sigfft shows only the left-hand side of the FFT\n# isigfft restores it by adding back the right-hand side then inverse FFT.\n\nifft <- function(x) fft(x/length(x), inverse = TRUE)\n\nsigfft <- function(x) {\n  tmp <- fft(x)\n  nyquist <- round((length(x) + 1.1 - (length(x) %% 2))/2)\n  tmp[1:nyquist]\n}\nisigfft <- function(Lfftx) {\n  tmp <- if (length(Lfftx) %% 2) {\n    # odd length\n    c(Lfftx, Conj(rev(Lfftx[c(-1, -length(Lfftx))])))\n\n  } else {\n    c(Lfftx, Conj(rev(Lfftx[-1])))\n  }\n  ifft(tmp) |> Re()\n}\n\nsquash_small <- function(x, tol=1e-9) {\n  r1 <- Re(x)\n  r1 <- ifelse(abs(r1) < tol, 0, r1)\n  c1 <- Im(x)\n  c1 <- ifelse(abs(c1) < tol, 0, c1)\n  # return real part if all of imaginary part is small\n  if (all(c1 == 0)) r1\n  else r1 + 1i * c1\n}\n\n# Plot the amplitude spectrum versus frequency\nsig_amp_spec <- function(x, sampfreq=100) {\n  Tmp <- tibble::tibble(\n    amp = abs(sigfft(x)),\n    frequency = seq(0, sampfreq/2, length = length(amp)))\n  Tmp |>\n    gf_segment(0 + amp ~ frequency + frequency, alpha = 0.2) |>\n    gf_point(amp ~ frequency, color = \"blue\", size = 0.5)\n}\n\n```\n:::\n\n\n# 2025-04-17 class notes\n\n1. Hand out map from walking project. Have students, in groups of two, draw a path.\n\n2. Fourier transform modeling project.\n\n## Polynomials as vectors\n\nConsider the polynomials over the interval $[-1,1]$:\n\n```{webr-r}\nslice_plot(x ~ x, domain(x = -1:1)) |>\n  slice_plot(x^2 ~ x, color = \"orange\") |>\n  slice_plot(x^3 ~ x, color = \"dodgerblue\") |>\n  slice_plot(x^4 ~ x, color = \"tomato\") |>\n  slice_plot(x^5 ~ x, color = \"steelblue\") |>\n  slice_plot(x^6 ~ x, color = \"red\") |>\n  slice_plot(x^7 ~ x, color = \"blue\") \n```\n\n\nMaking a matrix of values:\n\n```{webr-r}\nx <- seq(-1, 1, length = 1001) |> vec()\nM <- cbind(1, x, x^2, x^3, x^4, x^5, x^6, x^7)\ncolnames(M) <- c(\"zeroth\", \"first\", \"second\", \"third\", \"fourth\", \"fifth\", \"sixth\", \"seventh\")\nsvd(M)$d\n```\n\nOrthogonalize them, plotting out the new functions:\n\n```{webr-r}\nQ <- qr.Q(qr(M))\ncolnames(Q) <- colnames(M)\nQdf <- cbind(x, as.data.frame(Q))\nQdf |>\n  gf_line(zeroth  ~ x) |>\n  gf_line(first   ~ x) |>\n  gf_line(second  ~ x, color = \"orange\") |>\n  gf_line(third   ~ x, color = \"dodgerblue\") |>\n  gf_line(fourth  ~ x, color = \"tomato\") |>\n  gf_line(fifth   ~ x, color = \"steelblue\", linewidth=2) |>\n  gf_line(sixth   ~ x, color = \"red\", linewidth=2) |>\n  gf_line(seventh ~ x, color = \"blue\", linewidth=2) \n```\n\n\n# The Basis Set and the Layout of the FFT\n\n\nMake some sinusoidal vectors. The first few components of the Fourier basis with $n=64$.\n\n```{webr-r}\nSines <- tibble::tibble(\n  t = 0:63,\n  DC = 1,\n  cos1 = cos(1*2*pi*t/64),\n  sin1 = sin(1*2*pi*t/64),\n  cos2 = cos(2*2*pi*t/64),\n  sin2 = sin(2*2*pi*t/64),\n  cos3 = cos(3*2*pi*t/64),\n  sin3 = sin(3*2*pi*t/64),\n  cos7 = cos(7*2*pi*t/64),\n  sin7 = sin(7*2*pi*t/64)\n)\n\nSines |> \n  gf_line(cos1 ~ t, color = \"dodgerblue\") |>\n  gf_line(sin3 ~ t, color = \"orange\") \n```\n\n```{webr-r}\nsigfft(Sines$DC) |> squash_small()\n```\n\n```{webr-r}\nsigfft(Sines$cos1) |> squash_small()\nsigfft(Sines$sin1) |> squash_small()\nsigfft(Sines$cos2) |> squash_small()\nsigfft(Sines$sin2) |> squash_small()\n# 0, 1, 0, 1, 0, 1\nsigfft(Sines$t %% 2) |> squash_small()\n# 1, -1, 1, -1, ...\nsigfft(1 - 2*(Sines$t%%2)) |> squash_small()\n\n# linear combinations\nsigfft(Sines$sin1 + 3*Sines$cos2) |> isigfft() |> squash_small() |> plot()\n```\n\n## Noise\n\n```{webr-r}\nsig_amp_spec(cos2)\nsig_amp_spec(rnorm(64))  \n\nsig_amp_spec(rnorm(64) +  Sines$cos2 )\n```\n\n\n## Sines as basis vectors\n\n\n## Example: Tides\nTo illustrate, consider the `mosaicCalc::RI_tide` data frame from which we will use two variables:\n\n- `level` the water height in meters\n- `hours` the time in hours after the start of April 2010\n\nMeasurements are made once a second. The record covers 108 hours: four and a half days.\n\n```{webr-r}\nRI_tide |> select(hour, level) |> head()\n```\n\nWe want to model the tide signal to figure out to what extent it is a linear combination of simple functions.\n\n```{webr-r}\nRI_tide |> gf_line(level ~ hour)\n```\n\nSince it's an oscillatory function, let's look for sinusoidal components. And since the tide is a daily phenomenon, we can start with a 1-day sine and cosine. We'll make the model matrix:\n\n```{webr-r}\nM1 <- with(RI_tide, cbind(1, sin(2*pi*hour/24), cos(2*pi*hour/24)))\nb <- with(RI_tide, vec(level))\nX <- qr.solve(M1, b)\nRI_tide$M1 <- M1 %*% X\nRI_tide |> gf_line(M1 ~ hour, color = \"blue\") |>\n  gf_line(level ~ hour) |>\n  gf_refine(scale_x_continuous(breaks = seq(0, 108, by = 4)))\n```\n\nWhat features is this model missing? What should we add in to the model matrix?\n\n```{webr-r}\nM2 <- with(RI_tide, cbind(M1, sin(2*2*pi*hour/12), cos(2*2*pi*hour/12)))\nX <- qr.solve(M2, b)\nRI_tide$M2 <- M2 %*% X\nRI_tide |> gf_line(M2 ~ hour, color = \"blue\") |>\n  gf_line(level ~ hour) |>\n  gf_refine(scale_x_continuous(breaks = seq(0, 108, by = 4)))\n```\n\nMuch better. But a period of 12 hours is a little short. We can estimate how much we need to increase the period: 5 hours out of about 100, so 5% increase in the period: 25.2 hours as a start\n\n```{webr-r}\nperiod2 = 24.8 #26.1 #25.2\nM3 <- with(RI_tide, \n           cbind(M2, \n                 sin(2*pi*hour/period2), cos(2*pi*hour/period2),\n                 sin(2*2*pi*hour/period2), cos(2*2*pi*hour/period2)\n                 ))\nX <- qr.solve(M3, b)\nRI_tide$M3 <- M3 %*% X\nRI_tide |> gf_line(M3 ~ hour, color = \"blue\") |>\n  gf_line(level ~ hour) |>\n  gf_refine(scale_x_continuous(breaks = seq(0, 108, by = 4))) \n```\n\nLook at the residual:\n\n```{webr-r}\nRI_tide <- RI_tide |> \n  mutate(resid3 = level - M3) \nRI_tide |>\n  gf_line(resid3 ~ hour, color = \"blue\") |>\n  gf_refine(scale_x_continuous(breaks = seq(0, 108, by = 4)))\n```\n\nWe can go looking for more regular periods in the residual. A systematic way to do it involves constructing a grand ${\\bf M}$ matrix that has every sinusoid in it. Solving ${\\bf M}\\ \\vec{\\bf x} = \\vec{\\bf b}$ for $\\vec{x}$ is called taking the **Fourier Transform* of the signal.\n\nWe'll look just at the amplitudes for each frequency, neglecting the phase of the sines.\n\n```{webr-r}\nsig_amp_spec(RI_tide$level, sampfreq = 60) |>\n  gf_lims( y = c(0, 2000)) |>\n  gf_refine(\n    scale_x_continuous(\n      limits = c(0.0,0.2), \n      sec.axis = \n      sec_axis(transform = ~ 1/ ., \n               breaks = c(seq(5, 24, by = 1),\n                          seq(24, 36, by = 2)), name = \"period (hrs)\")))\n```\n\n```{webr-r}\nM4 <- with(RI_tide, \n           cbind(M3, \n                 sin(2*2*pi*hour/period2), cos(2*2*pi*hour/period2),\n                 sin(3*2*pi*hour/period2), cos(3*2*pi*hour/period2),\n                 sin(4*2*pi*hour/period2), cos(4*2*pi*hour/period2),\n                 sin(3*2*pi*hour/24), cos(3*2*pi*hour/24),\n                 sin(4*2*pi*hour/24), cos(4*2*pi*hour/24)\n                 ))\nX <- qr.solve(M4, b)\nRI_tide$M4 <- M4 %*% X\nRI_tide |> gf_line(M4 ~ hour, color = \"blue\") |>\n  gf_line(level ~ hour) |>\n  gf_refine(scale_x_continuous(breaks = seq(0, 108, by = 4))) \n```\n\nInterpolate the Anchorage tide\n\n```{webr-r}\nAnchorage_fixed <- with(Anchorage_tide, spline(hour, level, n = 88000)) |> as.data.frame()\nnames(Anchorage_fixed) <- c(\"hours\", \"level\")\n```\n\n```{webr-r}\nsig_amp_spec(RI_tide$level, sampfreq = 10.07273) |>\n  gf_lims(x = c(0, .15), y = c(0, 500))\n```\n\n```{webr-r}\nsvd(M)$d\nsvd(Q)$d\n```\n\n```{webr-r}\n#| caption: User console A\n#| persist: true\n```\n\n```{webr-r}\n#| caption: User console B\n#| persist: true\n```\n\n```{webr-r}\n#| caption: User console C\n#| persist: true\n```\n\n\n",
    "supporting": [
      "index-04-17-2025_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}