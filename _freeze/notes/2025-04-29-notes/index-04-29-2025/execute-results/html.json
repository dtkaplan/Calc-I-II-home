{
  "hash": "b33e6b8980c831d6a89b80c0c1a098f8",
  "result": {
    "engine": "knitr",
    "markdown": "---\nauthor: DTK\ndate: 2025-04-29\nnumber-offset: 41\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.callout-tip collapse=true}\n## Background software\n```{webr-r}\n#| autorun: true\n#| context: output\n# Drawing vectors and matrices\n\ndraw_matrix <- function(M) {\n  image(1:ncol(M), 1:nrow(M), t(M[nrow(M):1, ]),\n        col = colorspace::diverging_hcl(\n          15, h = c(180, 50), c = 80,\n          l = c(20, 95), power = c(0.7, 1.3)),\n        axes = FALSE,\n        useRaster = TRUE)\n}\n\nsomevecs <- tibble::tribble(\n  ~ rootx, ~ rooty, ~ headx, ~ heady, ~ color, ~ name,\n  0, 0, -2, 4, \"blue\", \"u\",\n  1, -2, 5, -3, \"green\", \"v\",\n  -1, -1, -4, -1, \"orange\", \"w\",\n  1, 0, 4, 3, \"brown\", \"x\",\n  0, -2, 3, -3, \"salmon\", \"y\",\n  0, 0, 4, 3, \"magenta\", \"b1\",\n  0, 0, -3, 2, \"magenta\", \"b2\",\n) |>\n  dplyr::mutate(labelx = (rootx + headx)/2,\n         labely = (2*rooty + heady)/3)\nsolve_for <- function(vecnames) {\n  somevecs |>\n    dplyr::filter(name %in% vecnames) |>\n    gf_segment(rooty + heady ~ rootx + headx,\n               arrow = grid::arrow(length=unit(0.15, \"inches\"), type=\"closed\"),\n               color = ~ color, linewidth=2) |>\n    gf_label(labely ~ labelx, label= ~ name, color = ~ color, size=3) |>\n    gf_refine(scale_color_identity(),\n              scale_y_continuous(limits=c(-5,5),\n                                 breaks=(-5):5),\n              scale_x_continuous(limits=c(-5,5),\n                                 breaks=(-5):5),\n              coord_fixed()) |>\n    gf_labs(x=\"\", y = \"\")\n}\n\n\nsolve_graph <- function(seed=101, integers=FALSE) {\n  set.seed(seed)\n  if (integers) {\n    u <- vec(sample(setdiff(-5:5, 0), size = 2))\n    v <- vec(sample(setdiff(-5:5, 0), size = 2))\n    # if too close in angle, try again\n    while ( abs((u %dot% v) / (veclen(u)*veclen(v))) > 0.6 )\n      v <- vec(sample(-5:5, size=2))\n  } else {\n    u <- vec(sample(c(-5:5, runif(3, -3, 3)), size = 2))\n    v <- vec(sample(c(-5:5, runif(3, -3, 3)), size = 2))\n    # if too close in angle, try again\n    while ( abs((u %dot% v) / (veclen(u)*veclen(v))) > 0.6 )\n      v <- vec(sample(c(-3:3, runif(3, -3, 3)), size=2))\n  }\n  ucoef <- sample(setdiff(-2:2, 0), size = 1)\n  vcoef <- sample(setdiff(-2:2, 0), size = 1)\n  b <- u*ucoef + v*vcoef\n  both <- matrix( c(0, 0, u, 0, 0, v, 0, 0, b),\n                  ncol=4, byrow = TRUE) |>\n    tibble::as_tibble()\n  names(both) <- c(\"rootx\", \"rooty\", \"headx\", \"heady\")\n  both$label <- c(\"a\", \"c\", \"b\")\n  both$color <- c(sample(c(\"blue\", \"darkorange\", \"tomato\", \"brown\",\"magenta\", \"red\"), size=2),\n                  \"forestgreen\")\n  both <- both |>\n    dplyr::mutate(labelx = (rootx + headx)/2,\n                  labely = (2*rooty + heady)/3)\n\n  longest <- round(max(abs(c(u, v, b))) + 1)\n  skip <- ifelse(longest > 7, 2, 1)\n\n  both |>\n    # dplyr::filter(label != \"b\") |>\n    gf_segment(rooty + heady ~ rootx + headx,\n               arrow = grid::arrow(length=unit(0.15, \"inches\"), type=\"closed\"),\n               color = ~ color, linewidth=2) |>\n    gf_label(labely ~ labelx, label= ~ label, color = ~ color, size=3) |>\n    gf_refine(scale_color_identity(),\n              scale_y_continuous(limits=c(-longest, longest),\n                                 breaks=seq(-longest, longest, by = skip)),\n              scale_x_continuous(limits=c(-longest, longest),\n                                 breaks=seq(-longest, longest, by = skip)),\n              coord_fixed()) |>\n    # gf_label(heady ~ headx,\n    #          label = ~ label,\n    #          color = ~ color,\n    #          data = both |> dplyr::filter(label == \"b\")) |>\n    gf_labs(x=\"\", y = \"\") |>\n    gf_refine(theme_minimal())\n}\n\n\n\n# Simple vector/matrix operations\n\nvec <- function(...) {\n  vals <- list(...) |> unlist()\n  matrix(vals, ncol=1)\n}\n\nrvec <- function(first, ..., rfun=rnorm) {\n  dots <- c(first, list(...)) |> unlist()\n  if (length(dots) == 1) {\n    dots <- rfun(dots[[1]])\n  }\n\n  vec(dots)\n}\n\n# Convenience functions on vectors and matrices\n\n# Give a colname to a vector or multiple colnames to a matrix\nvec_names <- `colnames<-`\n# Vector minus the mean\nvec_mm <- function(...)  {\n  v <- vec(...)\n  v - mean(v, na.rm = TRUE)\n}\n\n# arbitrary vec->vec or vec->scalar function applied to each column of a vector\nM_map <- function(M, f = \"center\") {\n  choices <- c(\"center\", \"unit\",\n               \"unitcenter\", \"mean\", \"var\", \"vlen\")\n\n  str <- as.character(substitute(f))\n  if (str[1] %in% choices) {\n    f <- switch (str[1],\n                 center = \\(x) (x - mean(x, na.rm = TRUE)),\n                 unit = \\(x) x / sqrt(sum(x^2)),\n                 mean = \\(x) mean(x, na.rm = TRUE),\n                 var = \\(x) var(x, na.rm = TRUE),\n                 len = \\(x) sqrt(sum(x*x)),\n                 len2 = \\(x) sum(x*x),\n                 unitcenter = function(x) {\n                   v <- x - mean(x, na.rm = TRUE)\n                   v / sqrt(sum(v^2))\n                 }\n    )\n  }\n  if (!is.function(f)) stop(\"Not a recognized function.\")\n  first <- f(M[,1])\n  res <- matrix(0, length(first), ncol(M))\n  for (k in 1:ncol(M)) {\n    res[, k] <- f(M[,k])\n  }\n  res\n}\n\n\n\nset_col_names <- function(v, nms) {\n  colnames(v) <- nms\n  v\n}\none_sided <- function(tilde) {\n if (length(tilde) == 3)\n   stop(\"The tilde expression should be one-sided, e.g. ~ b, not a ~ b\")\n}\n# create a model matrix pipe style\ndata_M <- function(.data, tilde) {\n  M <- model.matrix(tilde, data = .data |> tibble::remove_rownames())\n  M[ , - which(colnames(M) == \"(Intercept)\"), drop = FALSE]\n}\n\nveclen <- function(v) sqrt(v %dot% v)\nunitvec <- function(vec) vec/length(vec)\ncang <- function(v, w) {(v %dot% w) / (veclen(v) * veclen(w))}\nmakeQ <- function(...) {\n  dots <- list(...) |> bind_cols()\n  qr.Q(qr(dots))\n}\n\ncheck_for_svd <- function(S) {\n  if (inherits(S, \"matrix\")) S <- svd(S)\n  if (!is.list(S) || !all(c(\"d\",\"v\", \"u\") %in% names(S)))\n    stop(\"Argument must be matrix or the SVD of a matrix.\")\n  S\n}\n\nrank_mat <- function(S, thresh = 0.01) {\n  S <- check_for_svd(S)\n  sum(S$d > S$d[1] * thresh)\n}\n\nrand_mat <- function(nrow=3, ncol=6, rank = pmin(nrow, ncol)) {\n  M <- matrix(runif(nrow*ncol), nrow = nrow, ncol = ncol)\n  if (rank >= nrow || rank >= ncol) {\n   M\n  } else {\n    approx_mat(S, n=sample(pmin(rank, nrow, ncol)))\n  }\n}\n\n# Grab rank 1 matrix from SVD\napprox_mat <- function(S, n=1, order = 0) { # input a matrix or the SVD of a matrix\n  S <- check_for_svd(S)\n  if (order > 0) {\n    inds1 <- order(c(S$u[,order]))\n    inds2 <- order(c(S$v[,order]))\n  } else {\n    inds1 <- 1:nrow(S$u)\n    inds2 <- 1:nrow(S$v)\n  }\n  partial <- 0 # initial value\n  for (k in n) {\n    partial <- partial +  S$d[k] * S$u[inds1,k, drop = FALSE] %*% t(S$v[inds2,k, drop = FALSE])\n  }\n\n  partial\n}\n\npretty_mat <- function(M) {\n  inds1 <- order(rowSums(M))\n  inds2 <- order(colSums(M))\n  M[inds1, inds2]\n}\n\n#' Generate a matrix whose elements are selected randomly from a set\n#' of specified values.\n#' @param nrow number of rows for the matrix produced\n#' @param ncol number of columns\n#' @param values the set from which to draw (randomly) the\n#' values in the matrix. Default: integers -9 to 9\nvalues_mat <- function(nrow=4, ncol=3, values = -9:9) {\n  matrix(sample(values, size = nrow * ncol, replace = TRUE),\n         nrow = nrow, ncol=ncol)\n}\n\n# Typeset matrices in LaTeX (for assignments and such)\nLmat <- function(nr, nc) {\n  values_mat(nr, nc) |> latex_helper()\n}\nlatex_helper <- function(matr) {\n  printmrow <- function(x) {\n\n    cat(cat(x,sep=\" & \"),\"\\\\\\\\ \\n\")\n  }\n\n  cat(\"\\\\left(\\\\begin{array}{r}\",\"\\n\")\n  body <- apply(matr,1,printmrow)\n  cat(\"\\\\end{array}\\\\right)\")\n}\n\n# Fourier transform stuff\n# sigfft shows only the left-hand side of the FFT\n# isigfft restores it by adding back the right-hand side then inverse FFT.\n\nifft <- function(x) fft(x/length(x), inverse = TRUE)\n\nsigfft <- function(x) {\n  tmp <- fft(x)\n  nyquist <- round((length(x) + 1.1 - (length(x) %% 2))/2)\n  tmp[1:nyquist]\n}\nisigfft <- function(Lfftx) {\n  tmp <- if (length(Lfftx) %% 2) {\n    # odd length\n    c(Lfftx, Conj(rev(Lfftx[c(-1, -length(Lfftx))])))\n\n  } else {\n    c(Lfftx, Conj(rev(Lfftx[-1])))\n  }\n  ifft(tmp) |> Re()\n}\n\nsquash_small <- function(x, tol=1e-9) {\n  r1 <- Re(x)\n  r1 <- ifelse(abs(r1) < tol, 0, r1)\n  c1 <- Im(x)\n  c1 <- ifelse(abs(c1) < tol, 0, c1)\n  # return real part if all of imaginary part is small\n  if (all(c1 == 0)) r1\n  else r1 + 1i * c1\n}\n\n# Plot the amplitude spectrum versus frequency\nsig_amp_spec <- function(x, sampfreq=100) {\n  Tmp <- tibble::tibble(\n    amp = abs(sigfft(x)),\n    frequency = seq(0, sampfreq/2, length = length(amp)))\n  Tmp |>\n    gf_segment(0 + amp ~ frequency + frequency, alpha = 0.2) |>\n    gf_point(amp ~ frequency, color = \"blue\", size = 0.5)\n}\n\n# Plotting a function with room for drawing the anti-deriv\ndrawFpair <- function(f, dom = domain(x = 0:4), bottom = -0.5, alpha=0) {\n  # alpha = 0 for problem\n  # alpha = 1 for answer\n  fname <- as.character(substitute(f))\n  vname <- names(dom)\n  tilde <- glue::glue(\"{fname}({vname}) ~ {vname}\")\n  label <- glue::glue(\"{fname}({vname})\")\n  Ftilde <- glue::glue(\"{toupper(fname)}({vname}) ~ {vname}\")\n  labelF <- glue::glue(\"{toupper(fname)}({vname})\")\n  P1 <- slice_plot(as.formula(tilde), dom, npts = 1000) |>\n    gf_labs(y = label, x = \"\") |>\n    gf_lims(y = c(bottom, NA)) |>\n    gf_hline(yintercept = 0, color = \"blue\", linetype = \"dashed\") |>\n    gf_theme(theme_minimal(base_size = 22))\n  assign(toupper(fname), antiD(as.formula(tilde)))\n  P2 <- slice_plot(as.formula(Ftilde), dom, alpha = alpha) |>\n    gf_labs(y = labelF, x = vname) |>\n    gf_hline(yintercept = 0, color = \"blue\", linetype = \"dashed\") |>\n    gf_theme(theme_minimal(base_size = 22))\n  list(P1 = P1, P2 = P2)\n}\n\n\n\n```\n:::\n\n\n\n# 2025-04-29 class notes\n\n## Definite and \"indefinite\" integrals\n\n\"Integration\" and anti-differentiation are closely related but distinct operations.\n\n1. Anti-differentiation takes a function as input and produces a function as output.\n2. \"Indefinite\" integration is the same as anti-differentiation, and is a first step in many cases to \"definite\" integration.\n3. \"Definite integration\" takes **two** inputs and produces a number (quantity) as output.\n    i. a function\n    ii. a domain\n    \n*MOSAIC Calculus* uses \"integration\" to refer to the *definite type* and \"anti-differentiation\" to produce a *function*. Often, but not always, you will use anti-differentiation as a first step in integrating.\n\nThe traditional notation is ubiquitous, so you have to understand it entirely.\n\n\nNotation | explanation\n---------|------------\n$$\\int f(x)\\ dx$$ | indefinite integral\n$$\\int_0^{10} f(x)\\ dx$$ | definite integral over the domain $0 \\leq x \\leq 10$\n`F <- antiD(f(x) ~ x)` | indefinite integral\n`F(10) - F(0)` | definite integral over the domain $0 \\leq x \\leq 10$\n\n\n$$\\Large\\text{A quantity:}\\ \\ \\ \\ \\  \\int_\\color{magenta}{\\boxed{\\,0\\,}}^\\color{red}{\\boxed{\\,10\\,}} \\color{brown}{\\boxed{\\,g\\,}}\\left(\\color{blue}{\\boxed{\\color{blue}{\\,t\\, }}}\\right) d\\ \\color{blue}{\\boxed{\\color{blue}{\\,t\\,}}}$$\n![](www/eq1.png)\n\nColor key:    \n\ni. **BLACK** is the punctuation framework for the expression. This is non-negotiable.\nii. [BROWN]{style=\"color: brown;\"} is the function to be integrated, the **integrand**\niii. [BLUE]{style=\"color: blue;\"} is the **with-respect-to** variable.\n     a. Almost always the with-respect-to variable is an argument to the integrand, so the with-respect-to variable occurs twice.\n     b. The name doesn't matter. It could be replaced with any other name without changing the meaning. Think of it as a pronoun.\niv. [MAGENTA]{style=\"color: magenta;\"} is the **lower bound** of the domain of integration.\nv. [RED]{style=\"color: red;\"} is the **upper bound** of the domain of integration.\n\n$$\\Large\\text{A function:}\\ \\ \\ \\ \\ \\color{orange}{\\boxed{\\strut G}}(\\color{green}{\\boxed{\\strut\\,x\\,}}) \\equiv \\int_\\color{magenta}{\\boxed{\\,\\,}}^\\color{red}{\\boxed{\\,\\,}} \\color{brown}{\\boxed{\\strut\\,g\\,}}\\left(\\color{blue}{\\boxed{\\color{blue}{\\strut\\,t\\, }}}\\right) d\\ \\color{blue}{\\boxed{\\color{blue}{\\strut\\,t\\,}}}$$ {#eq-just-G}\n\n![](www/eq2.png)\n\nvi. [GREEN]{style=\"color: green;\"} is the name used as the argument for the function produced by the operation. Since the with-respect-to variable name is arbitrary, we can use any name we like for the argument to the output function. A good default is to use the name of the with-respect-to variable.\nvii. [ORANGE]{style=\"color: orange;\"} the name we choose for the output function.\n\nEquivalent in `{mosaicCalc}`:\n\n$$\\Large \\color{orange}{\\boxed{\\strut {\\mathtt G}}} \\leftarrow \\mathtt{antiD}\\left(\\right. {\\color{brown}{\\boxed{\\strut \\mathtt{\\,g\\,}}}}( \\color{green}{\\boxed{\\strut\\,t\\,}} )\\ \\sim \\color{green}{\\boxed{\\strut\\,t\\,}}\\ )$$\n\n![](www/eq3.png)\n\n$$\\Large\\text{A function:}\\ \\ \\ \\ \\ H(\\color{magenta}{\\boxed{\\strut\\,a\\,}}, \\color{red}{\\boxed{\\strut\\,b\\,}}) \\equiv \\int_\\color{magenta}{\\boxed{\\strut\\,a\\,}}^\\color{red}{\\boxed{\\strut\\,b\\,}} \\color{brown}{\\boxed{\\strut\\,g\\,}}\\left(\\color{blue}{\\boxed{\\color{blue}{\\strut\\,t\\, }}}\\right) d\\ \\color{blue}{\\boxed{\\color{blue}{\\strut\\,t\\,}}}$${#eq-definite-integral}\n\n![](www/eq4.png)\n\nAnother way to write this:\n\n$$\\Large\\text{Definite integral:}\\ \\ \\ \\color{orange}{\\boxed{\\strut {\\mathtt G}}}( \\color{red}{\\boxed{\\strut\\,b\\,}} )   \\ - \\ \\color{orange}{\\boxed{\\strut {\\mathtt G}}}( \\color{magenta}{\\boxed{\\strut\\,a\\,}} )$$ {#eq-G-minus-G}\n\n![](www/eq5.png)\n\ni. Note: If both $a$ and $b$ are numbers, the result is a **definite integral**, hence, not a function but a number (quantity).\n\nI think the situation is clearer in computer notation:\n\n::: {style=\"font-size:28;\"}\n```r\nG <- antiD(g(t) ~ t)\nH <- makeFun(G(b) - G(a) ~ a & b)\n```\n\ni. Notice that `H()` is a function of *both* `a` and `b` and *always* has the simple form `G(b) - G(a)`. \nii. The order `G(b) - G(a)` is important.\n\n## Constant of integration\n\nThere is another, equivalent convention for @eq-definite-integral which replaces the lower bound for integration by a constant, usually named $C$:\n\n$$\\Large\\text{A function:}\\ \\ \\ \\ \\ \\color{orange}{\\boxed{\\strut\\, G\\,}}\\left(\\color{red}{\\boxed{\\strut\\,b\\,}}\\right) \\equiv \\int_\\color{magenta}{\\boxed{\\strut\\,a\\,}}^\\color{red}{\\boxed{\\strut\\,b\\,}} \\color{brown}{\\boxed{\\strut\\,g\\,}}\\left(\\color{blue}{\\boxed{\\color{blue}{\\strut\\,t\\, }}}\\right) d\\ \\color{blue}{\\boxed{\\color{blue}{\\strut\\,t\\,}}}\\ + \\color{forestgreen}{\\boxed{\\strut\\,C\\,}}$$\n![](www/eq6.png)\n\nvii. [GREEN]{style=\"color: forestgreen;\"} the **constant of integration**.\n\ni. Notice that if $\\color{green}{C} = G(a)$, then this is exactly equivalent to @eq-G-minus-G.\n\n`{mosaicCalc}`'s `antiD()` gives you this format directly, but assigns a default value to C of zero so that you can ignore it if you wish.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nG <- antiD(cos(t) ~ t)\nG\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nfunction (t, C = 0) \nsin(t) + C\n```\n\n\n:::\n:::\n\n\n\n## Pattern-book functions\n\nWe've already memorized the derivatives of the pattern-book functions:\n\nname     | formula | $\\partial_t$ function\n---------|----------|-------------\nconst    | 1 | 0\nidentity | $t$ | 1\nsquare   | $t^2$ | $2 t$\ngaussian | dnorm$(t)$ | $t\\ \\text{dnorm}(t)$\nsigmoid  | pnorm$(t)$ | dnorm$(t)$\nsine     | $\\sin(t)$ | $\\cos(t)$\nlogarithm      | $\\ln(t)$  | $1/t$\nexponential    | $\\exp(t)$ or $e^t$ | $\\exp(t)$ or $e^t$\npower-law      | $t^k$  | $k t^{k-1}$ when $k \\neq 0$\n\ni. In the happy situation where the **integrand** $f(t)$ in $\\int f(t) dt$ is one of the derivatives of the pattern book functions, you know that the anti-derivative will be that pattern book function.\nii. Any other time that you recognize the **integrand** as the derivative of a function you know, then that known function will be the result of anti-differentiation.\n\n## Basic modeling functions\n\nThe basic modeling functions are the pattern-book functions $g(t)$ with input and/or output scaling, e.g. when $f()$ where is a pattern book function.\n\n$g(t) = A f(a t + b) + B$ or, equivalently $g(t) = A f(a (t - t_0)) + B$.\n\nHere's the basic rule for when the integrand is the derivative of a basic modeling function:\n\n$$\\large\\int  \\left[\\strut A f'(a t + b) + B\\right] dt = \\int A f'(a t + b)dt + \\int B\\, dt \\ =\\ \\frac{A}{a} \\left[f(at + b)\\right] + B\\,t + C$$\n\nFor instance: $$\\large \\int \\cos(\\omega t) dt = \\frac{1}{\\omega} sin(\\omega t) + C$$\n\n\n\n## Differentiation undoes anti-differentiation and *vice versa*\n\nAnti-differentiation undoes differentiation\n$$\\LARGE f(t)\\ = \\int \\partial_t \\left[f(t)\\right] dt\\ = \\ \\partial_t\\left[ \\int f(t) dt\\right]$$\n\n\n## Dimension example\n\nThere are typos\n\n{{{< include ../../../../MC-Workbook/Block_4/differential-orbit.qmd >}}}\n\n\n\n\n\n\n```{webr-r}\n#| caption: User console A\n#| persist: true\n```\n\n```{webr-r}\n#| caption: User console B\n#| persist: true\n```\n\n```{webr-r}\n#| caption: User console C\n#| persist: true\n```\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}