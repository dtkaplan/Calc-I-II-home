{
  "hash": "ff78b0a7c27ee52824facd64d7afb552",
  "result": {
    "engine": "knitr",
    "markdown": "---\nauthor: DTK\ndate: 2025-06-12\nnumber-offset: 58\nformat: live-html\nwebr:\n  channel-type: 'automatic'\n  repos: [\"https://dtkaplan.r-universe.dev\"]\n  packages: ['ggplot2', 'mosaicCalc', \"LSTbook\" ]\nfilters:\n  - webr\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n::: {.callout-tip collapse=true}\n## Background software\n```{webr-r}\n#| autorun: true\n#| context: output\n# Drawing vectors and matrices\n\ndraw_matrix <- function(M) {\n  image(1:ncol(M), 1:nrow(M), t(M[nrow(M):1, ]),\n        col = colorspace::diverging_hcl(\n          15, h = c(180, 50), c = 80,\n          l = c(20, 95), power = c(0.7, 1.3)),\n        axes = FALSE,\n        useRaster = TRUE)\n}\n\nsomevecs <- tibble::tribble(\n  ~ rootx, ~ rooty, ~ headx, ~ heady, ~ color, ~ name,\n  0, 0, -2, 4, \"blue\", \"u\",\n  1, -2, 5, -3, \"green\", \"v\",\n  -1, -1, -4, -1, \"orange\", \"w\",\n  1, 0, 4, 3, \"brown\", \"x\",\n  0, -2, 3, -3, \"salmon\", \"y\",\n  0, 0, 4, 3, \"magenta\", \"b1\",\n  0, 0, -3, 2, \"magenta\", \"b2\",\n) |>\n  dplyr::mutate(labelx = (rootx + headx)/2,\n         labely = (2*rooty + heady)/3)\nsolve_for <- function(vecnames) {\n  somevecs |>\n    dplyr::filter(name %in% vecnames) |>\n    gf_segment(rooty + heady ~ rootx + headx,\n               arrow = grid::arrow(length=unit(0.15, \"inches\"), type=\"closed\"),\n               color = ~ color, linewidth=2) |>\n    gf_label(labely ~ labelx, label= ~ name, color = ~ color, size=3) |>\n    gf_refine(scale_color_identity(),\n              scale_y_continuous(limits=c(-5,5),\n                                 breaks=(-5):5),\n              scale_x_continuous(limits=c(-5,5),\n                                 breaks=(-5):5),\n              coord_fixed()) |>\n    gf_labs(x=\"\", y = \"\")\n}\n\n\nsolve_graph <- function(seed=101, integers=FALSE) {\n  set.seed(seed)\n  if (integers) {\n    u <- vec(sample(setdiff(-5:5, 0), size = 2))\n    v <- vec(sample(setdiff(-5:5, 0), size = 2))\n    # if too close in angle, try again\n    while ( abs((u %dot% v) / (veclen(u)*veclen(v))) > 0.6 )\n      v <- vec(sample(-5:5, size=2))\n  } else {\n    u <- vec(sample(c(-5:5, runif(3, -3, 3)), size = 2))\n    v <- vec(sample(c(-5:5, runif(3, -3, 3)), size = 2))\n    # if too close in angle, try again\n    while ( abs((u %dot% v) / (veclen(u)*veclen(v))) > 0.6 )\n      v <- vec(sample(c(-3:3, runif(3, -3, 3)), size=2))\n  }\n  ucoef <- sample(setdiff(-2:2, 0), size = 1)\n  vcoef <- sample(setdiff(-2:2, 0), size = 1)\n  b <- u*ucoef + v*vcoef\n  both <- matrix( c(0, 0, u, 0, 0, v, 0, 0, b),\n                  ncol=4, byrow = TRUE) |>\n    tibble::as_tibble()\n  names(both) <- c(\"rootx\", \"rooty\", \"headx\", \"heady\")\n  both$label <- c(\"a\", \"c\", \"b\")\n  both$color <- c(sample(c(\"blue\", \"darkorange\", \"tomato\", \"brown\",\"magenta\", \"red\"), size=2),\n                  \"forestgreen\")\n  both <- both |>\n    dplyr::mutate(labelx = (rootx + headx)/2,\n                  labely = (2*rooty + heady)/3)\n\n  longest <- round(max(abs(c(u, v, b))) + 1)\n  skip <- ifelse(longest > 7, 2, 1)\n\n  both |>\n    # dplyr::filter(label != \"b\") |>\n    gf_segment(rooty + heady ~ rootx + headx,\n               arrow = grid::arrow(length=unit(0.15, \"inches\"), type=\"closed\"),\n               color = ~ color, linewidth=2) |>\n    gf_label(labely ~ labelx, label= ~ label, color = ~ color, size=3) |>\n    gf_refine(scale_color_identity(),\n              scale_y_continuous(limits=c(-longest, longest),\n                                 breaks=seq(-longest, longest, by = skip)),\n              scale_x_continuous(limits=c(-longest, longest),\n                                 breaks=seq(-longest, longest, by = skip)),\n              coord_fixed()) |>\n    # gf_label(heady ~ headx,\n    #          label = ~ label,\n    #          color = ~ color,\n    #          data = both |> dplyr::filter(label == \"b\")) |>\n    gf_labs(x=\"\", y = \"\") |>\n    gf_refine(theme_minimal())\n}\n\n\n\n# Simple vector/matrix operations\n\nvec <- function(...) {\n  vals <- list(...) |> unlist()\n  matrix(vals, ncol=1)\n}\n\nrvec <- function(first, ..., rfun=rnorm) {\n  dots <- c(first, list(...)) |> unlist()\n  if (length(dots) == 1) {\n    dots <- rfun(dots[[1]])\n  }\n\n  vec(dots)\n}\n\n# Convenience functions on vectors and matrices\n\n# Give a colname to a vector or multiple colnames to a matrix\nvec_names <- `colnames<-`\n# Vector minus the mean\nvec_mm <- function(...)  {\n  v <- vec(...)\n  v - mean(v, na.rm = TRUE)\n}\nset_col_names <- function(v, nms) {\n  colnames(v) <- nms\n  v\n}\none_sided <- function(tilde) {\n if (length(tilde) == 3)\n   stop(\"The tilde expression should be one-sided, e.g. ~ b, not a ~ b\")\n}\n# create a model matrix pipe style\ndata_M <- function(.data, tilde) {\n  M <- model.matrix(tilde, data = .data |> tibble::remove_rownames())\n  M[ , - which(colnames(M) == \"(Intercept)\"), drop = FALSE]\n}\n\nveclen <- function(v) sqrt(v %dot% v)\nunitvec <- function(vec) vec/length(vec)\ncang <- function(v, w) {(v %dot% w) / (veclen(v) * veclen(w))}\nmakeQ <- function(...) {\n  dots <- list(...) |> bind_cols()\n  qr.Q(qr(dots))\n}\n\ncheck_for_svd <- function(S) {\n  if (inherits(S, \"matrix\")) S <- svd(S)\n  if (!is.list(S) || !all(c(\"d\",\"v\", \"u\") %in% names(S)))\n    stop(\"Argument must be matrix or the SVD of a matrix.\")\n  S\n}\n\nrank_mat <- function(S, thresh = 0.01) {\n  S <- check_for_svd(S)\n  sum(S$d > S$d[1] * thresh)\n}\n\nrand_mat <- function(nrow=3, ncol=6, rank = pmin(nrow, ncol)) {\n  M <- matrix(runif(nrow*ncol), nrow = nrow, ncol = ncol)\n  if (rank >= nrow || rank >= ncol) {\n   M\n  } else {\n    approx_mat(S, n=sample(pmin(rank, nrow, ncol)))\n  }\n}\n\n# Grab rank 1 matrix from SVD\napprox_mat <- function(S, n=1, order = 0) { # input a matrix or the SVD of a matrix\n  S <- check_for_svd(S)\n  if (order > 0) {\n    inds1 <- order(c(S$u[,order]))\n    inds2 <- order(c(S$v[,order]))\n  } else {\n    inds1 <- 1:nrow(S$u)\n    inds2 <- 1:nrow(S$v)\n  }\n  partial <- 0 # initial value\n  for (k in n) {\n    partial <- partial +  S$d[k] * S$u[inds1,k, drop = FALSE] %*% t(S$v[inds2,k, drop = FALSE])\n  }\n\n  partial\n}\n\npretty_mat <- function(M) {\n  inds1 <- order(rowSums(M))\n  inds2 <- order(colSums(M))\n  M[inds1, inds2]\n}\n\n#' Generate a matrix whose elements are selected randomly from a set\n#' of specified values.\n#' @param nrow number of rows for the matrix produced\n#' @param ncol number of columns\n#' @param values the set from which to draw (randomly) the\n#' values in the matrix. Default: integers -9 to 9\nvalues_mat <- function(nrow=4, ncol=3, values = -9:9) {\n  matrix(sample(values, size = nrow * ncol, replace = TRUE),\n         nrow = nrow, ncol=ncol)\n}\n\n# Typeset matrices in LaTeX (for assignments and such)\nLmat <- function(nr, nc) {\n  values_mat(nr, nc) |> latex_helper()\n}\nlatex_helper <- function(matr) {\n  printmrow <- function(x) {\n\n    cat(cat(x,sep=\" & \"),\"\\\\\\\\ \\n\")\n  }\n\n  cat(\"\\\\left(\\\\begin{array}{r}\",\"\\n\")\n  body <- apply(matr,1,printmrow)\n  cat(\"\\\\end{array}\\\\right)\")\n}\n\n# Fourier transform stuff\n# sigfft shows only the left-hand side of the FFT\n# isigfft restores it by adding back the right-hand side then inverse FFT.\n\nifft <- function(x) fft(x/length(x), inverse = TRUE)\n\nsigfft <- function(x) {\n  tmp <- fft(x)\n  nyquist <- round((length(x) + 1.1 - (length(x) %% 2))/2)\n  tmp[1:nyquist]\n}\nisigfft <- function(Lfftx) {\n  tmp <- if (length(Lfftx) %% 2) {\n    # odd length\n    c(Lfftx, Conj(rev(Lfftx[c(-1, -length(Lfftx))])))\n\n  } else {\n    c(Lfftx, Conj(rev(Lfftx[-1])))\n  }\n  ifft(tmp) |> Re()\n}\n\nsquash_small <- function(x, tol=1e-9) {\n  r1 <- Re(x)\n  r1 <- ifelse(abs(r1) < tol, 0, r1)\n  c1 <- Im(x)\n  c1 <- ifelse(abs(c1) < tol, 0, c1)\n  # return real part if all of imaginary part is small\n  if (all(c1 == 0)) r1\n  else r1 + 1i * c1\n}\n\n# Plot the amplitude spectrum versus frequency\nsig_amp_spec <- function(x, sampfreq=100) {\n  Tmp <- tibble::tibble(\n    amp = abs(sigfft(x)),\n    frequency = seq(0, sampfreq/2, length = length(amp)))\n  Tmp |>\n    gf_segment(0 + amp ~ frequency + frequency, alpha = 0.2) |>\n    gf_point(amp ~ frequency, color = \"blue\", size = 0.5)\n}\n\n```\n:::\n\n\n# 2025-06-12 class notes\n\n```{webr-r}\n#| caption: User console A\n#| persist: true\n```\n\n```{webr-r}\n#| caption: User console B\n#| persist: true\n```\n\n```{webr-r}\n#| caption: User console C\n#| persist: true\n```\n\n\n",
    "supporting": [
      "index-06-12-2025_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}