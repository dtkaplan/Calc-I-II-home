{
  "hash": "9401eb34d4fac514f288496e13c4ba92",
  "result": {
    "engine": "knitr",
    "markdown": "---\nauthor: DTK\ndate: 2025-04-04\nnumber-offset: 32\nformat: live-html\n---\n\n\n\n\n\n\n\n# 2025-04-04 class notes\n\n::: {.callout-tip collapse=true}\n## Console A\n```{webr-r}\n#| persist: true\n\n```\n:::\n\n::: {.callout-tip collapse=true}\n## Console B\n```{webr-r}\n#| persist: true\n\n```\n:::\n\n::: {.callout-tip collapse=true}\n## Console C\n```{webr-r}\n#| persist: true\n\n```\n:::\n\n## Dot product and the correlation coefficient\n\nHere's the way we did things in QR2:\n\n```{webr-r}\nGalton |> model_train(height ~ mother) |>\n  R2()\n```\n\nThe correlation coefficient is the square root of R^2^ for for a model with only one explanatory variable where both the response and the explanatory variables are quantitative.\n\n```{webr-r}\nsqrt(0.0406647)\n```\n\nNow let's compute the dot-product and the cosine of the inclusive angle by data wrangling. \n\n```{webr-r}\nGalton |>\n  mutate(standardH = (height - mean(height))/sd(height),\n         standardM = (mother - mean(mother))/sd(mother)) |>\n  summarize(dotproduct = sum(standardH * standardM),\n            lenH = sqrt(sum(standardH^2)),\n            lenM = sqrt(sum(standardM^2)),\n            cosTheta = dotproduct / (lenH * lenM))\n```\n## Addition\n\n## Scaling\n\nScaling provides the way to turn a vector into a space.\n\n## Linear combination\n\nA way to produce a space defined by two or more vectors.\n\nWhat is modeling in terms of vectors. Find the best linear combination of vectors (explanatory terms) to approximate the response vector.\n\n\n\n## Functions as vectors\n\nGaussians over a two second-window\n\n```{webr-r}\nstep = 2^(1/12)\n\nSounds <- tibble::tibble(\n  time = (0:44100)/22050,\n  g1 = pmin(1.0, dnorm(time, mean = 1, sd=0.5)),\n  g2 = pmin(1.0, dnorm(time, mean = 0.25, sd=0.2)),\n  g3 = pmin(1.0, dnorm(time, mean = .75, sd=0.2)),\n  g4 = pmin(1.0, dnorm(time, mean = 1.25, sd=0.1)),\n  one =    sin(step^0  * 2 * pi * 440 * time),\n  two =    sin(step^1  * 2 * pi * 440 * time),\n  three =  sin(step^2  * 2 * pi * 440 * time),\n  four =   sin(step^3  * 2 * pi * 440 * time),\n  five =   sin(step^4  * 2 * pi * 440 * time),\n  six =    sin(step^5  * 2 * pi * 440 * time),\n  seven =  sin(step^6  * 2 * pi * 440 * time),\n  eight =  sin(step^7  * 2 * pi * 440 * time),\n  nine =   sin(step^8  * 2 * pi * 440 * time),\n  ten =    sin(step^9  * 2 * pi * 440 * time),\n  eleven = sin(step^10 * 2 * pi * 440 * time),\n  twelve = sin(step^11 * 2 * pi * 440 * time)\n)  |>\n  mutate(sum = g2*three + g2*five + g2*seven + 2*three^2)\n\n# audio::play(Sounds$sum / 10, rate = 22050)\n```\n\n## Matrices\n\nMatrix of random numbers\n\n```{webr-r}\nMrand <- matrix(rnorm(40*30), nrow=40, ncol=30)\ndraw_matrix(Mrand)\n```\n\n## Subspaces\n\nWhat's the subspace spanned by 3 vectors on a table?\n\n## SVD and the dimension of subspaces\n\nCreate some vectors, then some linear combinations of them than look at the singular values.\n\n```{webr-r}\nu <- rbind(1,2,3, 6, -2)\nv <- rbind(2,5,3, -4, 1)\nw <- 3*u - 2*v\nx <- w - u\ny <- u + v - w\nM <- cbind(u, v, w, x, y)\nM |> svd() |> purrr::pluck(\"d\")\n```\n\n```{webr-r}\ndraw_matrix(M)\nM\n```\n\n```{webr-r}\nM <- Sounds |> \n  select(one, two, three, four, five, \n         six, seven, eight, nine, ten, eleven, twelve) |>\n  as.matrix(ncol = 12) \nM |> svd() |> purrr::pluck(\"d\")\n```\n\n```{webr-r}\n#| results: hide\n#| autorun: true\n# Drawing vectors and matrices\n\ndraw_matrix <- function(M) {\n  image(1:ncol(M), 1:nrow(M), t(M[nrow(M):1, ]),\n        col = colorspace::diverging_hcl(\n          15, h = c(180, 50), c = 80,\n          l = c(20, 95), power = c(0.7, 1.3)),\n        axes = FALSE)\n}\n\nsomevecs <- tibble::tribble(\n  ~ rootx, ~ rooty, ~ headx, ~ heady, ~ color, ~ name,\n  0, 0, -2, 4, \"blue\", \"u\",\n  1, -2, 5, -3, \"green\", \"v\",\n  -1, -1, -4, -1, \"orange\", \"w\",\n  1, 0, 4, 3, \"brown\", \"x\",\n  0, -2, 3, -3, \"salmon\", \"y\",\n  0, 0, 4, 3, \"magenta\", \"b1\",\n  0, 0, -3, 2, \"magenta\", \"b2\",\n) |>\n  mutate(labelx = (rootx + headx)/2,\n         labely = (2*rooty + heady)/3)\nsolve_for <- function(vecnames) {\n  somevecs |>\n    filter(name %in% vecnames) |>\n    gf_segment(rooty + heady ~ rootx + headx,\n               arrow = grid::arrow(length=unit(0.15, \"inches\"), type=\"closed\"),\n               color = ~ color, linewidth=2) |>\n    gf_label(labely ~ labelx, label= ~ name, color = ~ color, size=3) |>\n    gf_refine(scale_color_identity(),\n              scale_y_continuous(limits=c(-5,5),\n                                 breaks=(-5):5),\n              scale_x_continuous(limits=c(-5,5),\n                                 breaks=(-5):5),\n              coord_fixed()) |>\n    gf_labs(x=\"\", y = \"\")\n}\n\n\n# Simple vector/matrix operations\n\nvec <- function(...) {\n  vals <- list(...) |> unlist()\n  matrix(vals, ncol=1)\n}\n\nrvec <- function(first, ..., rfun=rnorm) {\n  dots <- c(first, list(...)) |> unlist()\n  if (length(dots) == 1) {\n    dots <- rfun(dots[[1]])\n  }\n\n  vec(dots)\n}\n\nveclen <- function(v) sqrt(v %dot% v)\nunitvec <- function(vec) vec/length(vec)\ncang <- function(v, w) {(v %dot% w) / (veclen(v) * veclen(w))}\nmakeQ <- function(...) {\n  dots <- list(...) |> bind_cols()\n  qr.Q(qr(dots))\n}\n\ncheck_for_svd <- function(S) {\n  if (inherits(S, \"matrix\")) S <- svd(S)\n  if (!is.list(S) || !all(c(\"d\",\"v\", \"u\") %in% names(S)))\n    stop(\"Argument must be matrix or the SVD of a matrix.\")\n  S\n}\n\nrank_mat <- function(S, thresh = 0.01) {\n  S <- check_for_svd(S)\n  sum(S$d > S$d[1] * thresh)\n}\n\nrand_mat <- function(nrow=3, ncol=6, rank = pmin(nrow, ncol)) {\n  M <- matrix(runif(nrow*ncol), nrow = nrow, ncol = ncol)\n  if (rank >= nrow || rank >= ncol) {\n   M\n  } else {\n    approx_mat(S, n=sample(pmin(rank, nrow, ncol)))\n  }\n}\n\n# Grab rank 1 matrix from SVD\napprox_mat <- function(S, n=1, order = 0) { # input a matrix or the SVD of a matrix\n  S <- check_for_svd(S)\n  if (order > 0) {\n    inds1 <- order(c(S$u[,order]))\n    inds2 <- order(c(S$v[,order]))\n  } else {\n    inds1 <- 1:nrow(S$u)\n    inds2 <- 1:nrow(S$v)\n  }\n  browser()\n  partial <- 0 # initial value\n  for (k in n) {\n    partial <- partial +  S$d[k] * S$u[inds1,k, drop = FALSE] %*% t(S$v[inds2,k, drop = FALSE])\n  }\n\n  partial\n}\n\npretty_mat <- function(M) {\n  inds1 <- order(rowSums(M))\n  inds2 <- order(colSums(M))\n  M[inds1, inds2]\n}\n\n\n```\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}