{
  "hash": "39ae17e4075a8d3117173295daf51d96",
  "result": {
    "engine": "knitr",
    "markdown": "---\nauthor: DTK\ndate: 2025-04-04\nnumber-offset: 32\nformat: live-html\n---\n\n\n\n\n\n# 2025-04-04 class notes\n\n## Dot product and the correlation coefficient\n\nHere's the way we did things in QR2:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGalton |> model_train(height ~ mother) |>\n  R2()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n    n k  Rsquared        F      adjR2            p df.num df.denom\n1 898 1 0.0406647 37.98001 0.03959401 1.078142e-09      1      896\n```\n\n\n:::\n:::\n\n\n\nThe correlation coefficient is the square root of R^2^ for for a model with only one explanatory variable where both the response and the explanatory variables are quantitative.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(0.0406647)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.2016549\n```\n\n\n:::\n:::\n\n\n\nNow let's compute the dot-product and the cosine of the inclusive angle by data wrangling. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nGalton |>\n  mutate(standardH = (height - mean(height))/sd(height),\n         standardM = (mother - mean(mother))/sd(mother)) |>\n  summarize(dotproduct = sum(standardH * standardM),\n            lenH = sqrt(sum(standardH^2)),\n            lenM = sqrt(sum(standardM^2)),\n            cosTheta = dotproduct / (lenH * lenM))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  dotproduct     lenH     lenM  cosTheta\n1   180.8844 29.94996 29.94996 0.2016549\n```\n\n\n:::\n:::\n\n\n## Addition\n\n## Scaling\n\n## Linear combination\n\n## Functions as vectors\n\nGaussians over a two second-window\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstep = 2^(1/12)\n\nSounds <- tibble::tibble(\n  time = (0:44100)/22050,\n  g1 = pmin(1.0, dnorm(time, mean = 1, sd=0.5)),\n  g2 = pmin(1.0, dnorm(time, mean = 0.25, sd=0.2)),\n  g3 = pmin(1.0, dnorm(time, mean = .75, sd=0.2)),\n  g4 = pmin(1.0, dnorm(time, mean = 1.25, sd=0.1)),\n  one =    sin(step^0  * 2 * pi * 440 * time),\n  two =    sin(step^1  * 2 * pi * 440 * time),\n  three =  sin(step^2  * 2 * pi * 440 * time),\n  four =   sin(step^3  * 2 * pi * 440 * time),\n  five =   sin(step^4  * 2 * pi * 440 * time),\n  six =    sin(step^5  * 2 * pi * 440 * time),\n  seven =  sin(step^6  * 2 * pi * 440 * time),\n  eight =  sin(step^7  * 2 * pi * 440 * time),\n  nine =   sin(step^8  * 2 * pi * 440 * time),\n  ten =    sin(step^9  * 2 * pi * 440 * time),\n  eleven = sin(step^10 * 2 * pi * 440 * time),\n  twelve = sin(step^11 * 2 * pi * 440 * time)\n)  |>\n  mutate(sum = g2*three + g2*five + g2*seven + 2*three^2)\n\naudio::play(Sounds$sum / 10, rate = 22050)\n```\n:::\n\n\n\n## Matrices\n\n## Subspaces\n\n## SVD and the dimension of subspaces\n\nCreate some vectors, then some linear combinations of them than look at the singular values.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nu <- rbind(1,2,3, 6, -2)\nv <- rbind(2,5,3, -4, 1)\nw <- 3*u - 2*v\nx <- w - u\ny <- u + v - w\nM <- cbind(u, v, w, x, y)\nM |> svd() |> pluck(\"d\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.497787e+01 9.949430e+00 2.307268e-15 7.028489e-16 3.353587e-16\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nM <- Sounds |> \n  select(one, two, three, four, five, \n         six, seven, eight, nine, ten, eleven, twelve) |>\n  as.matrix(ncol = 12) \nM |> svd() |> pluck(\"d\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 148.8119 148.7251 148.6554 148.6368 148.5805 148.5579 148.4850 148.4543\n [9] 148.3874 148.3514 148.1686 148.1048\n```\n\n\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}