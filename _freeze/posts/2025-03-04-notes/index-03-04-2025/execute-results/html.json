{
  "hash": "b6442eaf943b12b5ee6264073dae68a5",
  "result": {
    "engine": "knitr",
    "markdown": "---\nauthor: DTK\ndate: 2025-03-04\nnumber-offset: 21\nformat: live-html\n---\n\n\n\n# 2025-03-04 class notes\n\n## Recursive nature of differentiation.\n\nConsider the structure of a tilde expression. We'll use this one as a running example:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTilde <- A*sin(x^2 + y*exp(k*x)) + B ~ x\n```\n:::\n\n\n\nThis doesn't have any compelling modeling context. I chose it to illustrate the mechanics of differentiation.\n\nWhat we call a \"tilde expression\" has a different standard name in the R language: a \"formula.\" We use \"tilde expression\" because we are reserving \"formula\" to use under its standard mathematical expression. But we will need some more R names to work with tilde expressions. Here's how to find out the \"class\" of an R object.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(Tilde)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"formula\"\n```\n\n\n:::\n:::\n\n\n\nThe tilde expression stored under the name `Tilde` has three parts: the tilde symbol itself, and two valid R expressions, one on the right and one on the left side.\n\nWhat do I mean by a valid R expression? A fragment of code that would be recognized as a complete command by R so long as bindings were provided giving values for the names: `A`, `x`, `y`, `k`, `B`.\n\nWe can look at each of the three parts separately. The double-bracket `[[]]` notation is effective here. We aren't using this notation elsewhere in *MOSAIC Calculus*. It relates to pulling a part out of a list. There is also a single-brack notation `[]` that pulls a list out of a list.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTilde[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n`~`\n```\n\n\n:::\n:::\n\n\n\nThe first part of `Tilde` is the tilde symbol itself. Notice, however, the two little back-ticks around the printed form of `Tilde[[1]]`. This indicates that `Tilde[[1]]` contains a \"name.\" It might be surprising, but the tilde symbol (with those backticks) is the name of a function, an infix operation much like `+` or `*`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(`~`)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"function\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(`+`)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"function\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(`*`)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"function\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(sin)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"function\"\n```\n\n\n:::\n:::\n\n\n\nThe object stored in slot 1 of `Tilde` is really the name of a function, whose printed form is the back-ticked tilde.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(Tilde[[1]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"name\"\n```\n\n\n:::\n:::\n\n\n\nThe other two parts of `Tilde` are objects, in this case, of class \"call.\" This signifies that each of the objects is an invocation of a *function* on arguments (as in \"call a function\").\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTilde[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nA * sin(x^2 + y * exp(k * x)) + B\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(Tilde[[2]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"call\"\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nTilde[[3]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nx\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(Tilde[[3]])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"name\"\n```\n\n\n:::\n:::\n\n\n\n\"Calls\" are also stored in a list fashion, just like tilde expressions. But instead of `~` being the first item of the list, the function itself is the first item. Functions can have zero, one, two, three, or more arguments, which are stored as items in the list.\n\nThose arguments can be numbers or R expressions, in this case, \"name\"s or \"call\"s.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nLeft <- Tilde[[2]]\nlength(Left)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3\n```\n\n\n:::\n\n```{.r .cell-code}\nLeft[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n`+`\n```\n\n\n:::\n\n```{.r .cell-code}\nLeft[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nA * sin(x^2 + y * exp(k * x))\n```\n\n\n:::\n\n```{.r .cell-code}\nLeft[[3]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nB\n```\n\n\n:::\n\n```{.r .cell-code}\nLeft[[1]] |> class()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"name\"\n```\n\n\n:::\n\n```{.r .cell-code}\nLeft[[2]] |> class()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"call\"\n```\n\n\n:::\n\n```{.r .cell-code}\nLeft[[3]] |> class()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"name\"\n```\n\n\n:::\n:::\n\n\n\nThe right-hand expression is simpler, consisting only of a name.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRight <- Tilde[[3]]\nlength(Right)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(Right)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"name\"\n```\n\n\n:::\n:::\n\n\n\nIn the case where an expression is a numeral, the \"type\" will be \"numeric.\" The derivative of a numeric expression is zero.\n\n```{webr-r}\n# define the rules as formulas\n\n```\n\nLet's start writing a symbolic differentiation function, keeping it very simple:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDsimp1 <- function(expression, wrt) {\n  if (is.name(expression) || is.numeric(expression)) {\n    if (expression == wrt) one()\n    else zero()\n  } else Dsimp2(expression, wrt)\n}\n```\n:::\n\n\n\nAnd some stand-ins for names used in `Dsimp1()`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDsimp2 <- function(expression, name) message(\"Kick the can down the road.\")\n```\n:::\n\n\n\nHandling constants as functions\n\nAll this does, at this point, is to check whether the expression given is a name, and, if so, return the appropriate function for the derivative of this name with respect to `wrt`.\n\nWe will also need a function to supervise the proces of differentiating an expression. For consistency with our use of tilde expressions to hold a formula and the WRT variables, this supervisory function will take a tilde expression as its only argument.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDriv <- function(tilde) {\n  Dsimp1(tilde[[2]], all.names(tilde[[3]])[1])\n}\n```\n:::\n\n\n\nLet's try out what we have so far:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDsuper(x ~ x)\nDsuper(y ~ x)\nDsuper(3 ~ x)\nDsuper(sin(x) ~ x)\n```\n:::\n\n\n\nSo far, so good. Now let's teach `Dsuper` another differentiation rule, the \"plus\" or \"minus\" rule. We'll package this into `Dsimp2()`, and make a new kick-the-can function `Dsimp3()` which we can elaborate on late.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDsimp3 <- Dsimp2 # kick the can\nDsimp2 <- function(expression, wrt) {\n  # Addition and subtraction\n  if (length(expression) > 1) {\n    # The first will be a function, the remaining arguments.\n    fun <- as.character(expression[[1]])\n    if (fun %in% c(\"+\", \"-\")) { \n      # apply the rule\n      part1 <- Dsimp1(expression[[2]], wrt)\n      part2 <- Dsimp1(expression[[3]], wrt)\n      # Simplification if possible\n      if (is_zero(part1)) return(part2)\n      if (is_zero(part2)) return(part1)\n      # It would be good to do some simplification here, like 1+1 ==> 2\n      if (is_constant(part1) && is_constant(part2)) {\n        return(make_constant(part1() + part2()))\n      }\n      # \n      expression[[2]] <- part1\n      expression[[3]] <- part2\n      return(expression)\n    } else {\n      Dsimp3(expression, wrt)\n    }\n    # we should never get here, since all valid\n    # length-1 expressions were handled by <Dsimp1>\n    stop(\"Length-one expression not handled by Dsimp1()?\")\n  }\n}\n```\n:::\n\n\n\nTry it out:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDsuper(x + 3 ~ x)\nDsuper(x + x + x ~ y)\nDsuper(x + x + x ~ x)\nDsuper( - x ~ x)\nDsuper(3 ^ x ~ x)\n```\n:::\n\n\n\nNow to handle simple cases: sin(), exp() where the leading function name will be replaced by cos() and exp() respectively. All we need is the chain rule. And we'll do a bit of simplification for zero() and one().\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDsimp4 <- Dsimp3\nDsimp3 <- function(expression, wrt) {\n  browser()\n  if (length(expression) <= 1) {\n    # we shouldn't get here\n    stop(\"Length-1 expression being handed to Dsimp3().\")\n  } \n  \n  if (length(expression) == 2) {\n    fname <- as.character(expression[[1]])\n    chain <- Dsimp1(expression[[2]], wrt)\n    \n    if (if (inherits(chain, \"constantval\") && chain() == 0) return(zero)\n    if (fname == \"sin\") {\n      if (chain == one) {\n        expression[[1]] <- cos\n        return(expression)\n      } else {\n        framework <- quote(1 * 1)\n        expression[[1]] <- cos\n        framework[[2]] <- expression\n        framework[[3]] <- chain\n        return(framework)\n      }\n    } else if (fname == \"exp\") {\n      if (chain == one) {\n        return(expression)\n      } else {\n        framework <- quote(1 * 1)\n        framework[[2]] <- expression\n        framework[[3]] <- chain\n      }\n      return(framework)\n    } else if (fname == \"^\") {\n      base <- expression[[2]]\n      dbase <- Dsimp1(base)\n      # Need to look at the first argument, to see if it's a constant\n      if (dbase != zero) {\n        return(Dsimp4(expression, wrt))\n      }\n      \n      if (chain == one) {\n        return(expression)\n      } else {\n        framework <- quote(1 * 1)\n        framework[[2]] <- expression\n        framework[[3]] <- chain\n        return(framework)\n      }\n      \n    } else {\n      stop(\"Add in other 1-argument functions here.\")\n    }\n  } else {\n    Dsimp4(expression, wrt)\n  }\n}\n```\n:::\n\n\n  \n\n\n\n-------------\n\nAdd activities from Ch 23 to lesson plan. 8-12\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}